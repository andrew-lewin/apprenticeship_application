<% provide(:title, 'About') %>
<h1>About</h1>
<p>I think the coolest thing I've made is the script to automate setting up our clients on Insight. Brennan offloaded the project over to me temporarily before he had engineering finish the rake task for it. I decided that it was taking me such a long time to setup that I would just automate it myself. I hadn't really done anything like this before, but I started researching how to automate things in a web browser and found the Capybara gem. After some fiddling around and looking up a couple of guides I was able to get things working.</p>

<p>I figured out how to get a session going in Capybara and was able to write a script that would sign me into Batcave and navigate over to where I would create an analytics client. I ran into a problem, though, when I needed to add a new binder, I needed to look for the link that said "Add". The only problem was, there were about five of those links on that page. After some Googling around, I learned was xpath was and how I could use that to tell Capybara which link I wanted. Once I finished the script, I was able to create a new Insight client in about 30 minutes, down from 2-3 hours doing it manually. After a couple of weeks I noticed that I was getting some requests to set these up pretty last minute, so I needed to speed up the script quite a bit. By this point, I had heard about multithreading in my object oriented programming class, so I decided to Google around and learn about multithreading in Ruby. I decided that I would initialize all of my variables with a single Capybara session, but once it came time to create the 11 different binders we needed, I would spawn 11 new threads that created their own Capybara sessions and made those independant of each other. This cut the creation time down to about 2-3 minutes, depending on the response times from Batcave, which is where it stands right now.</p>

<p>I quickly realized that just setting up these clients wasn't enough. I also had to maintain them, which meant that if we, for instance, added a new binder, like the feature visits, I had to cycle through each Insight client and create those new queries. Of course, since I already knew how to create the clients, I decided to make a class that knew how to navigate through batcave to create Insight clients and then I would just call the methods that I needed to create the things that needed to be done in that particular setup. That way I had one class that handled creating them from scratch and adding new binders or queries.</p>

<p>The other two projects that I made to make things easier and faster while on support are the demo user script and the client setup script. They use many of the same things that the Insight script does, but came with a couple of unique challenges. I realized that some of our clients were already waiting on new demo users to be setup by the time 7:00 AM rolled around, before I was in the office to run the script. Because of that, I figured out how to schedule a job to be run on my computer early in the morning on the first of every month. For the client setup script, I didn't want to take a lot of user input, but knew there were some differences in how I would set up a client based on which accessor they were under. To solve this, I would store which accessor the client was under and made a case statement to make sure to get the settings right.</p>

<p>Outside of work, I've also been going to school. Some of the most difficult challenges I had to solve came out of my Algorithms and Data Structures class. One of those assignments was called Percolation. Basically, you had a bunch of tiles inside of a square, say 100x100 squares. If you clicked on one of them it would turn white, but if you clicked on a square that was on the top row, the tile would turn blue. If another square was adjacent to one that was blue; up, down, right, or left, no diagonals; it would also turn blue. Once you had a path that went from top to bottom it was considered to be percolating and the program would let you know. So basically the assignment was how to tell if two nodes are connected in the same group very quickly. My first thought about how to solve this was to just keep track of two different arrays. One array would have the elements I wanted in it and then the other array would keep track of the group these elements are in. The first element in that group would just have its own element number to identify the group. If another element was being added to that group, I'd just mark it that way in the group array. The problem, however, came when I tried to merge two groups. Now I had to run through every element in the group and update them to the new group. Obviously, this causes problems when you are looking at things in terms of big O. The way that we eventually solved this problem was to keep track of just the parent in a group. So one node would have one parent that it points to and many children pointing to it. This way in order to find out if two nodes are in the same group, you just follow the chain up to the root parent and compare if they are the same. So, the solution to the assignment was actually kind of tricky. Along with the tiles, I made a virtual top node that all nodes at the top would point to if they were clicked on. Then I did the same thing for the bottom row. This way, in order to check if the tiles were percolating, I just had to compare if the root parent of the bottom virtual node was the top virtual node.</p>
